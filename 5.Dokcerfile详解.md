# 5.Dockerfile #

在前面，我们多次提到Dockerfile这个东西，现在我们就来一步一步的了解它。

## 5.1基本结构 ##

Dockerfile是由一行行命令语句组成，并且支持以#开头的注释行。通常，Dockerfile分为四个部分：基础镜像信息、维护者信息、镜像操作指令和容器启动时执行命令。

如下案例：
    
    # VERSION   2.2
    
    # use the ubuntu base image provided by dotCloud
    #第一行必须指定基于的基础镜像
    FROM ubuntu
    #维护者信息
    MAINTAINER Victor Coisne victor.coisne@dotcloud.com
    
    # make sure the package repository is up to date
    #镜像的操作指令
    RUN echo "deb http://archive.ubuntu.com/ubuntu precise main universe" > /etc/apt/sources.list
    RUN apt-get update
    
    # install memcached
    RUN apt-get install -y memcached
    #容器启动时执行的命令
    CMD /bin/bash
    
1、指令

指令的格式一般是：INSTAUCTION  agreements，指令包括FROM、MAINTIAINER、RUN、CMD等。注意：指令不区分大小写，但是命名约定为全部大写。

（1）FROM

    格式：FROM  <Image> 或 FROM <Image>:<tag>   
    提示：第一条指令必须为FROM指令，并且，如果在同一个Dockerfile中创建多个镜像时，可以使用多个FROM指令（一个镜像一次）
    
（2）MAINTAINER
    
    格式：MAINTAINER <author-name>
    
（3）RUN
    
    格式：RUN <command> 或 RUN [”executable”,”parma1”,”parma2”](数组形式)
    
    提示：
    1.前者将在shell终端运行命令，即：/bin/sh –c  <command>；
    2.后者则使用exec执行。  指定使用其他终端可以通过第二种方式实现，如：RUN [”/bin/bash”,”-c”,”echo hello ”]
    3.每条RUN指令将在当前镜像上执行指定的命令，并提交为新的镜像，当命令较长时可以使用\来换行。
    
（4）CMD

    格式：CMD [”executable”,”parmar1”,”parmar2”]使用exec执行，推荐
      CMD command param1 param2 在/bin/sh 中执行，提供给需要交互的应用
      CMD [”param1”,”param2”]提供给ENTRYPOINT的默认参数
    
    提示：指定容器时，执行的命令，每个Dockerfile只能有一条CMD命令。如果指定了多条命令，只有最后一条会被执行。
    如果使用者启动容器时指定了运行的命令，则会覆盖掉CMD指定的命令。
    
（5）EXPOSE

    格式：EXPOSE <port> [<port> ...]
    
    这个是告诉Docker服务端容器暴露的端口号，供互联系统使用。在启动容器时需要通过-P（大写），Docker主机会自动分配一个端口转发到指定的端口；-p，则可以具体指定哪个本地端口映射过来。
    
例如：
    
    #private and public port
    EXPOSE 80:8080
    #private
    EXPOSE 80
    提示：Dockerfile中你有能力映射私有和公有端口，但是你永远不要通过Dockerfile映射公有端口。通过映射公有端口到主机上，你将只能运行一个容器化应用程序实例。切记：不要在Dockerfile中映射公有端口。
    
（6）ENV

    格式：ENV <key> <value>
    指定一个环境变量，会被后续RUN指令使用，并在容器运行时保持。
例如：

    ENV PG_MAJOR  9.3
    ENV PG_VERSION  9.3.4
    RUN curl –SL  httop://emample.com/postagres-$PG_VERSION.tar.gz|tar –xJC  /usr/src/postgress  &&  ...
    ENV PATH /usr/local/postpress-$PG_MAJOR/bin:$PATH
    
（7）ADD

    格式：ADD <src> <dest>
    
    该命令将复制指定的<src>到容器的<dest>。其中<src>可以是Dockerfile所在目录的一个相对路径（文件或目录）；也可以是一个URL，还可以是一个tar文件（自动解压为目录）。
    
（8）COPY

    格式：COPY <src> <dest>
    
    复制本地主机的<src>（为Dockerfile所在目录的相对路径，文件或目录）为容器的<dest>，目标路径不存在时，会自动创建。
    
（9）ENTRYPOINT
    
    格式：ENTRYPOINT [”executable”，”param1”，”param2”]
      ENTRYPOINT command param1  param2 （shell中执行）
    
    配置容器启动后执行的命令，并且不可被docker run提供的参数覆盖。
    每个Dockerfile中只能有一个ENTRYPOINT，当指定多个ENTRYPOINT时，只有最后的一个生效。
    
（10）VOLUME

    格式：VOLUME  [”/data”]
    
    创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。
    
（11）USER

    格式：USER daemon
    1.指定运行容器的用户或UID，后续的RUN也会使用指定用户。
    2.当服务不需要管理员权限时，可以通过该命令指定运行用户，并且可以在之前创建所需要的用户，例如：RUN groupadd  -r postgres  && useradd –r –g postgres  postgres
    3.想要获得临时的管理员权限可以使用gosu，不推荐sudo  ？？？
    
（12）WORKDIR

    格式：WORKDIR /path/to/workdir
    
    为后续的RUN、CMD、ENTRYPOINT指令配置工作目录。可以使用多个WORKDIR指令，后续命令如果是相对路径，则会基于之前命令指定的路径。
    如：
    WORKDIR  /a
    WORKDIR  b
    WORKDIR  c
    RUN  pwd
    则最终路径为/a/b/c
    
13）ONBUILD

    格式：ONBUILD [INSTRUCTION]
    
    配置当所创建的镜像作为其他新镜像的基础镜像时，所执行的操作指令（有点类似Django模板继承的原理）。
    如下：
    使用Dockerfile创建镜像image-A
    [...]	
    ONBUILD ADD . /app/src
    ONBUILD RUN  /usr/local/bin/python-build  --dir /app/src
    [...]

下面是基于image-A创建新的镜像，新的Dockerfile中使用FROM image-A 指定基础镜像，会自动执行ONBUILD指令内容，等价于在后面添加了两条指令：
    
    FROM image-A
    #自动运行
    ADD .  /app/src
    RUN /usr/local/bin/python-build  --dir  /app/src
    
    提示：使用ONBUILD指令的镜像，推荐在标签中注明，例如：python:2.7.6-onbuild
    
## 5.2创建镜像 ##

Dockerfile的基础指令我们在上面已经介绍了，下面我们就来用Dockerfile创建自己的镜像吧。


    命令格式：docker build []

我等菜鸟该做的就是：
    
    [root@cxp ~]# docker  build --help
    
    Usage: docker build [OPTIONS] PATH | URL | -
    
    Build a new image from the source code at PATH
    
      -f, --file=""Name of the Dockerfile(Default is 'Dockerfile' at context root)
      --force-rm=false Always remove intermediate containers, even after unsuccessful builds
      --help=false Print usage
      --no-cache=false Do not use cache when building the image
      --pull=false Always attempt to pull a newer version of the image
      -q, --quiet=falseSuppress the verbose output generated by the containers
      --rm=trueRemove intermediate containers after a successful build
      -t, --tag="" Repository name (and optionally a tag) to be applied to the resulting image in case of success
    
    所有操作一目了然！
    解析：
    1.该命令是将读取指定路径下（包括子目录）的Dockerfile，并将该路径下所有内容发送给Docker服务端，由服务端来创建镜像。因此，建议放置Dockerfile的目录为空目录
    2.我们也可以通过 .dockerignore文件（每行添加一条匹配模式）来让Docker
    忽略路径下的目录和文件
    
实战

构建Dockerfile文件：

    [root@cxp test]#vim Dockerfile
    FROM ubuntu
    MAINTAINER Michael Crosby <michael@crosbymichael.com>
    RUN echo "deb http://archive.ubuntu.com/ubuntu precise main universe" > /etc/apt/sources.list
    RUN apt-get update
    RUN apt-get upgrade –y

用Dockerfile创建镜像：
    
    [root@cxp test]# docker  build  -t='ubuntu:latest' .  #注意这个点哦！
    Sending build context to Docker daemon 13.82 kB
    Sending build context to Docker daemon 
    Step 0 : FROM ubuntu
     ---> 07f8e8c5e660
    Step 1 : MAINTAINER Michael Crosby <michael@crosbymichael.com>
     ---> Running in 332323c1c73f
     ---> c5e8067827aa
    Removing intermediate container 332323c1c73f
    Step 2 : RUN echo "deb http://archive.ubuntu.com/ubuntu precise main universe" > /etc/apt/sources.list
     ---> Running in c4f6f8a11b03
     ---> cf0326bda9b0
    Removing intermediate container c4f6f8a11b03
    Step 3 : RUN apt-get update
     ---> Running in 78f80e3b9488
    Ign http://archive.ubuntu.com precise InRelease
    Get:1 http://archive.ubuntu.com precise Release.gpg [198 B]
    Get:2 http://archive.ubuntu.com precise Release [49.6 kB]
    Get:3 http://archive.ubuntu.com precise/main amd64 Packages [1640 kB]
    Get:4 http://archive.ubuntu.com precise/universe amd64 Packages [6167 kB]
    Fetched 7857 kB in 2min 1s (64.6 kB/s)
    Reading package lists...
     ---> 001473dac18b
    Removing intermediate container 78f80e3b9488
    Step 4 : RUN apt-get upgrade -y
     ---> Running in 54f24fc51070
    Reading package lists...
    Building dependency tree...
    Reading state information...
    0 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.
     ---> 247ada23d529
    Removing intermediate container 54f24fc51070
    Successfully built 247ada23d529
    
    最后，显示成功建立！

来查看一下吧：

    [root@cxp test]# docker images 
    REPOSITORY  TAG IMAGE IDCREATED VIRTUAL SIZE
    ubuntu  latest  247ada23d5296 minutes ago   196.1 MB
    <none>  <none>  65be804b671630 minutes ago  202.6 MB
    <none>  <none>  9a40e15fe25038 minutes ago  188.3 MB
    
Dockerfile的基础知识到这里也就结束了，深入的知识我们会在后继续学，更多的练习我们会在后面的实战中体现出来！

下面推荐两篇文章关于Dockerfile的运行机制和优化的：http://dockone.io/article/346
http://dockone.io/article/255